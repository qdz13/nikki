#!/bin/bash
# shellcheck disable=SC2015,SC2086,SC2207,SC2209

# FUNCTIONS

usage() {
	echo "Usage: $progname [-h] [-p pager] [command] [options]" >&2
	cat >&2 <<-'EOF'

	Global options:
	  -h, --help     Display this help message and exit
	  -p, --pager    Set pager (cat, less, bat (default), glow)

	Commands:
	  edit
	  ls
	  read
	  rm
	  tree
	  restore

	EOF
	echo "To see the usage of each commands, run \`$progname [command] -h\`"
}

perror() {
	echo "$progname:" "$@" >&2
}

rmoldcache() {
	# Delete backup files that are more than 3 days old
	[ -d "$datadir/backup" ] && find "$datadir/backup" -type f -mtime +3 -delete
}

cleanup() {
	[ -n "$tmp" ] && rm -f "$tmp"
}

maketmp() {
	# Avoid using `mktemp` to enable syntax highlighting in Neovim
	tmp="/tmp/$progname.md"
	trap 'cleanup' HUP INT QUIT PIPE TERM
}

# SUBCOMMANDS

usage_edit() {
	echo "Usage: $progname edit [-hp] [[[yyyy]mm]dd ...]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help  Display this help message and exit
	  -p, --past  Edit past diary
	EOF
}

sc_edit() {
	local i past old fname f
	local -a dates

	past=false
	old=false
	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_edit
				exit
				;;
			-p|--past) past=true ;;
			-*)
				perror "Invalid option: $1"
				usage_edit
				exit 1
				;;
			*)
				if [[ $1 =~ ^[0-9]{2}$ ]]; then
					dates+=("$(date '+%Y%m')$1")
				elif [[ $1 =~ ^[0-9]{4}$ ]]; then
					dates+=("$(date '+%Y')$1")
				elif [[ $1 =~ ^[0-9]{8}$ ]]; then
					dates+=("$1")
				else
					usage_edit
					exit 1
				fi
				old=true
				;;
		esac
		shift
	done
	[ ${#dates[@]} -eq 0 ] && dates+=("$(date '+%Y%m%d')")

	maketmp

	mkdir -p "$datadir/backup"
	for i in "${dates[@]}"; do
		fname="${i:0:4}/${i:4:2}/${i:6:2}"
		f="$datadir/$fname.md"
		if [ "$old" = true ]; then
			if [ "$past" = false ]; then
				perror "Use -p to edit past diaries"
				usage_edit
				exit 1
			elif ! [ -e "$f" ]; then
				perror "$i: No such diary"
				exit 1
			fi
		fi
		mkdir -p "${f%/*}"
		[ -e "$f" ] && sed 1,4d "$f" > "$tmp"

		"$editor" "$tmp"

		if [ -e "$f" ]; then
			cmp -s <(sed 1,4d "$tmp") "$f" && return
			cp "$f" "$datadir/backup/${fname//\//}.md"
		else
			[ -s "$tmp" ] || return
		fi

		{
			printf -- "---\ndate: %s\n---\n\n" "$fname"
			cat "$tmp"
		} > "$f"
	done
}

usage_ls() {
	echo "Usage: $progname ls [-h] [[yyyy]mm ...]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help    Display this help message and exit
	EOF
}

sc_ls() {
	local i month
	local -a dirs

	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_ls
				exit
				;;
			-*)
				perror "Invalid option: $1"
				usage_ls
				exit 1
				;;
			*)
				if [[ $1 =~ ^[0-9]{2}$ ]]; then
					dirs+=("$(date '+%Y')/$1")
					month=true
				elif [[ $1 =~ ^[0-9]{4}$ ]]; then
					dirs+=("$1")
					month=false
				elif [[ $1 =~ ^[0-9]{6}$ ]]; then
					dirs+=("${1:0:4}/${1:4:2}")
					month=true
				else
					usage_ls
					exit 1
				fi
				;;
		esac
		shift
	done
	if [ ${#dirs[@]} -eq 0 ]; then
		find "$datadir" -not -name "$progname" -not -name backup -type d -maxdepth 1 -print |
			sed  -e "s|^$datadir/||" -e 's|/||g' -e 's/\.md$//' | sort -n
		exit
	fi

	for i in "${dirs[@]}"; do
		[ -d "$datadir/$i" ] || continue
		{
			if [ "$month" = true ]; then
				find "$datadir/$i" -not -name "$i" -type f -maxdepth 1 -print
			else
				find "$datadir/$i" -not -name "$i" -type d -maxdepth 1 -print
			fi
		} | sed -e "s|^$datadir/||" -e 's|/||g' -e 's/\.md$//' | sort -n
	done
}

usage_read() {
	echo "Usage: $progname read [-h] [[[yyyy]mm]dd ...]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help    Display this help message and exit
	EOF
}

sc_read() {
	local i f
	local -a dates

	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_read
				exit
				;;
			-*)
				perror "Invalid option: $1"
				usage_read
				exit 1
				;;
			*)
				if [[ $1 =~ ^[0-9]{2}$ ]]; then
					dates+=("$(date '+%Y%m')$1")
				elif [[ $1 =~ ^[0-9]{4}$ ]]; then
					dates+=("$(date '+%Y')$1")
				elif [[ $1 =~ ^[0-9]{8}$ ]]; then
					dates+=("$1")
				else
					usage_read
					exit 1
				fi
				;;
		esac
		shift
	done
	[ ${#dates[@]} -eq 0 ] && dates+=("$(date '+%Y%m%d')")

	for i in "${dates[@]}"; do
		f="$datadir/${i:0:4}/${i:4:2}/${i:6:2}.md"
		if ! [ -e "$f" ]; then
			perror "$i: No such diary"
			continue
		fi
		"${pagercmd[@]}" "$f"
	done
}

usage_rm() {
	echo "Usage: $progname rm [-h] [[[yyyy]mm]dd ...]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help    Display this help message and exit
	EOF
}

sc_rm() {
	local i f
	local -a dates

	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_rm
				exit
				;;
			-*)
				perror "Invalid option: $1"
				usage_rm
				exit 1
				;;
			*)
				if [[ $1 =~ ^[0-9]{2}$ ]]; then
					dates+=("$(date '+%Y%m')$1")
				elif [[ $1 =~ ^[0-9]{4}$ ]]; then
					dates+=("$(date '+%Y')$1")
				elif [[ $1 =~ ^[0-9]{8}$ ]]; then
					dates+=("$1")
				else
					usage_rm
					exit 1
				fi
				;;
		esac
		shift
	done

	if [ ${#dates[@]} -eq 0 ]; then
		usage_rm
		exit 1
	fi

	for i in "${dates[@]}"; do
		f="${i:0:4}/${i:4:2}/${i:6:2}.md"
		if ! [ -e "$datadir/$f" ]; then
			perror "$i: No such diary"
			continue
		fi
		mv "$datadir/$f" "$datadir/backup/$i.md"
		echo "Removed $i"
	done
}

usage_tree() {
	echo "Usage: $progname tree [-h]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help    Display this help message and exit
	EOF
}

sc_tree() {
	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_tree
				exit
				;;
			-*)
				perror "Invalid option: $1"
				usage_tree
				exit 1
				;;
			*)
				usage_tree
				exit 1
				;;
		esac
	done

	{
		printf "\033[34m\033[1m%s\033[0m\n" "$progname"
		tree -C -I backup "$datadir" | sed '1d'
	} | less
}

usage_restore() {
	echo "Usage: $progname restore [-h]" >&2
	cat >&2 <<-'EOF'

	Options:
	  -h, --help    Display this help message and exit
	EOF
}

sc_restore() {
	local answer i f
	local -a files

	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage_restore
				exit
				;;
			-*)
				perror "Invalid option: $1"
				usage_restore
				exit 1
				;;
			*)
				usage_restore
				exit 1
				;;
		esac
	done

	if ! [ -e "$datadir/backup" ]; then
		perror "Couldn't find any backup file"
		exit 1
	fi

	files=($(find "$datadir/backup" -type f -print 2>/dev/null |
			 sed -e "s|^$datadir/backup/||g" -e 's/\.md$//g' | sort -nr))
	if [ ${#files[@]} -eq 0 ]; then
		perror "Couldn't find any backup file"
		exit 1
	elif [ ${#files[@]} -eq 1 ]; then
		f="${files[0]}"
	else
		for i in $(seq ${#files[@]}); do
			printf "[%d] %d\n" $i ${files[i-1]}
		done
		read -er -p "Enter a number: " answer
		if ! [[ $answer =~ ^[0-9]*$ ]]; then
			perror "$answer: Not a number"
			exit 1
		fi
		if [ $answer -gt ${#files[@]} ] || ((answer == 0)); then
			perror "$answer: Invalid number"
			exit 1
		fi
		f="${files[answer-1]}"
	fi

	echo "$f is selected"
	while :; do
		read -er -p "[S]ee the backup file, [R]estore it, or [E]xit? [E] " answer
		case "$answer" in
			s|S)
				"${pagercmd[@]}" "$datadir/backup/$f.md"
				break
				;;
			r|R)
				mv "$datadir/backup/$f.md" "$datadir/${f:0:4}/${f:4:2}/${f:6:2}.md"
				break
				;;
			""|e|E) exit ;;
		esac
	done
}

# MAIN

main() {
	local i subcmd pager
	declare progname datadir editor tmp
	declare -a pagercmd

	progname=nikki
	datadir="${XDG_DATA_HOME:-$HOME/.local/share}/$progname"
	[ -d "$datadir" ] || mkdir -p "$datadir"
	#shellcheck disable=SC2153
	editor="${EDITOR:-$VISUAL}"
	if [ -z "$editor" ]; then
		perror "Failed to set the editor"
		exit 1
	fi

	subcmd=edit
	while [ $# -ne 0 ]; do
		case "$1" in
			-h|--help)
				usage
				exit
				;;
			-p|--pager)
				shift
				if [ $# -eq 0 ]; then
					usage_read
					exit 1
				fi
				pager="$1"
				;;
			-*)
				perror "Invalid option: $1"
				usage
				exit 1
				;;
			edit) break ;;
			ls)
				subcmd=ls
				break
				;;
			read)
				subcmd=read
				break
				;;
			rm)
				subcmd=rm
				break
				;;
			tree)
				subcmd=tree
				break
				;;
			restore)
				subcmd=restore
				break
				;;
			*)
				usage
				exit 1
				;;
		esac
		shift
	done
	shift

	case "$pager" in
		cat)
			pagercmd=(cat)
			;;
		less)
			pagercmd=(less)
			;;
		""|bat)
			pagercmd=(bat --style plain --paging always)
			;;
		glow)
			pagercmd=(glow --pager)
			;;
		*)
			perror "$pager: Invalid pager"
			exit 1
			;;
	esac

	rmoldcache

	case "$subcmd" in
		edit) sc_edit "$@" ;;
		ls) sc_ls "$@" ;;
		read) sc_read "$@" ;;
		rm) sc_rm "$@" ;;
		tree) sc_tree "$@" ;;
		restore) sc_restore "$@" ;;
	esac

	cleanup

	return 0
}

main "$@"
